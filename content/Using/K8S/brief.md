+++
title = 'K8s的理解'
date = 2024-03-07T15:00:59+08:00
weight = 20
+++

### 一、核心定位：云时代的操作系统

我对 K8s 最根本的理解是：**它正在成为数据中心/云环境的“操作系统”。**

*   **传统操作系统（如 Windows、Linux）**：管理的是单台计算机的硬件资源（CPU、内存、硬盘、网络），并为应用程序（进程）提供运行环境。
*   **Kubernetes**：管理的是一个**集群**（由多台计算机组成）的资源，并将这些物理机/虚拟机抽象成一个巨大的“资源池”。它在这个池子上调度和运行的不再是简单的进程，而是**容器化了的应用程序**。

所以，你可以把 K8s 看作是一个分布式的、面向云原生应用的操作系统。

---

### 二、要解决的核心问题：从“动物园”到“牧场”

在 K8s 出现之前，微服务和容器化架构带来了新的挑战：

1.  **编排混乱**：我有成百上千个容器，应该在哪台机器上启动？如何知道它们是否健康？挂了怎么办？如何扩容缩容？
2.  **网络复杂**：容器之间如何发现和通信？如何实现负载均衡？
3.  **存储管理**：有状态应用的数据如何持久化？容器漂移后数据怎么跟走？
4.  **部署麻烦**：如何实现蓝绿部署、金丝雀发布？如何回滚？

这个时期被称为“集装箱革命”后的“编排战争”时期，各种工具（如 Docker Swarm, Mesos, Nomad）就像是一个混乱的“动物园”。

K8s 的诞生（源于 Google 内部系统 Borg 的经验）就是为了系统地解决这些问题，它将混乱的“动物园”管理成了一个井然有序的“牧场”。它的核心能力可以概括为：**声明式 API 和控制器模式**。

---

### 三、核心架构与工作模型：大脑与肢体

K8s 集群主要由**控制平面** 和**工作节点** 组成。

*   **控制平面：集群的大脑**
    *   **kube-apiserver**：整个系统的唯一入口，所有组件都必须通过它来操作集群状态。它是“前台总机”。
    *   **etcd**：一个高可用的键值数据库，持久化存储集群的所有状态数据。它是“集群的记忆中心”。
    *   **kube-scheduler**：负责调度，决定 Pod 应该在哪个节点上运行。它是“人力资源部”。
    *   **kube-controller-manager**：运行着各种控制器，不断检查当前状态是否与期望状态一致，并努力驱使其一致。例如，节点控制器、副本控制器等。它是“自动化的管理团队”。

*   **工作节点：干活的肢体**
    *   **kubelet**：节点上的“监工”，负责与控制平面通信，管理本节点上 Pod 的生命周期，确保容器健康运行。
    *   **kube-proxy**：负责节点上的网络规则，实现 Service 的负载均衡和网络代理。
    *   **容器运行时**：如 containerd 或 CRI-O，负责真正拉取镜像和运行容器。

**工作模型的核心：声明式 API 与控制器模式**
1.  你向 `kube-apiserver` 提交一个 YAML/JSON 文件，**声明**你期望的应用状态（例如：我要运行 3 个 Nginx 实例）。
2.  `etcd` 记录下这个期望状态。
3.  各种**控制器**会持续地“观察”当前状态，并与 `etcd` 中的期望状态进行对比。
4.  如果发现不一致（例如，只有一个 Nginx 实例在运行），控制器就会主动采取行动（例如，再创建两个 Pod），直到当前状态与期望状态一致。
5.  这个过程是**自愈的、自动的**。

---

### 四、关键对象与抽象：乐高积木

K8s 通过一系列抽象对象来建模应用，这些对象就像乐高积木：

1.  **Pod**：**最小部署和管理单元**。一个 Pod 可以包含一个或多个紧密关联的容器（如主容器和 Sidecar 容器），它们共享网络和存储。这是 K8s 的“原子”。
2.  **Deployment**：**定义无状态应用**。它管理 Pod 的多个副本（Replicas），并提供滚动更新、回滚等强大的部署策略。这是最常用的对象。
3.  **Service**：**定义一组 Pod 的访问方式**。Pod 是“ ephemeral ”的，IP 会变。Service 提供一个稳定的 IP 和 DNS 名称，并作为负载均衡器，将流量分发给后端的健康 Pod。它是“服务的门户”。
4.  **ConfigMap & Secret**：将配置信息和敏感数据与容器镜像解耦，实现配置的灵活管理。
5.  **Volume**：抽象了各种存储解决方案，为 Pod 提供持久化存储。
6.  **Namespace**：在物理集群内部创建多个虚拟集群，实现资源隔离和多租户管理。
7.  **StatefulSet**：**用于部署有状态应用**（如数据库）。它为每个 Pod 提供稳定的标识符、有序的部署和扩缩容，以及稳定的持久化存储。
8.  **Ingress**：管理集群外部访问内部服务的入口，通常提供 HTTP/HTTPS 路由、SSL 终止等功能。它是“集群的流量总入口”。

---

### 五、核心价值与优势

1.  **自动化运维**：自动化了应用的部署、扩缩容、故障恢复（自愈）、滚动更新等，极大降低了运维成本。
2.  **声明式配置与不可变基础设施**：通过 YAML 文件定义一切，基础设施可版本化、可追溯、可重复。这是 DevOps 和 GitOps 的基石。
3.  **环境一致性 & 可移植性**：实现了“一次编写，随处运行”。无论是在本地开发机、测试环境，还是在公有云、混合云上，应用的行为都是一致的。
4.  **高可用性与弹性伸缩**：轻松实现应用的多副本部署，并能根据 CPU、内存等指标或自定义指标进行自动扩缩容，从容应对流量高峰。
5.  **丰富的生态系统**：拥有一个极其庞大和活跃的社区，提供了大量的工具和扩展（Helm, Operator, Istio等），能解决几乎所有你能想到的问题。

---

### 六、挑战与学习曲线

K8s 并非银弹，它也有自己的挑战：
*   **复杂性高**：概念繁多，架构复杂，学习和运维成本非常高。
*   **“配置”沉重**：YAML 文件可能非常多，管理起来本身就是一门学问。
*   **网络与存储**：虽然是核心抽象，但其底层实现和理解起来依然有相当的门槛。

### 总结

在我看来，Kubernetes 不仅仅是一个容器编排工具，它更是一套**云原生应用的管理范式**。它通过一系列精妙的抽象，将复杂的分布式系统管理问题标准化、自动化和简单化。虽然入门有门槛，但它已经成为现代应用基础设施的事实标准，是任何从事后端开发、运维、架构设计的人员都必须理解和掌握的核心技术。

简单来说，**K8s 让你能够像管理一台超级计算机一样，去管理一个由成千上万台机器组成的集群。**